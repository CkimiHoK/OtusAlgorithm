=================================================================================================
===========(       Операция: добавление элементов в конец массива (ADD)      )===================
=================================================================================================
TEST: COLL_SIZE       |     SINGLE    |     VECTOR    |     FACTOR   |    MATRIX    |    STANDART 
------------------------------------------------------------------------------------------------
test.1.in:          1 |     0.000024  |     0.000020  |    0.000011  |    0.000037  |    0.000008
test.2.in:         10 |     0.000126  |     0.000033  |    0.000049  |    0.000061  |    0.000013
test.3.in:        100 |     0.002382  |     0.000391  |    0.000206  |    0.000479  |    0.000068
test.4.in:      1.000 |     0.225596  |     0.023109  |    0.002394  |    0.005398  |    0.000655
test.5.in:     10.000 |    24.282623  |     2.244536  |    0.021805  |    0.046212  |    0.006445
test.6.in:    100.000 |     TOO SLOW  |   233.227422  |    0.216370  |    0.460785  |    0.065382
test.7.in:  1.000.000 |     TOO SLOW  |     TOO SLOW  |    2.595800  |    4.908150  |    0.689563
test.8.in: 10.000.000 |     TOO SLOW  |     TOO SLOW  |   24.029410  |   49.062713  |    6.744853

Вывод: 
Как можно заметить с каждым улучшением простого SINGLE динамического массива мы получаем значительный выигрыш в производительности.
Это обусловлено тем что количество операций копирования элементов внутреннего массива при расширение уменьшается.
Становится очевидно, что FACTOR вариант наиболее предпочтителен и является лучшим из наших решений.
Ну и само собой нативная реализация динамического массива языка STANDART работает намного намного быстрее.


=================================================================================================
==========(       Операция: получение случайного элемента в массиве (GET)      )=================
=================================================================================================
TEST: COLL_SIZE       |     SINGLE    |     VECTOR    |     FACTOR   |    MATRIX    |    STANDART 
------------------------------------------------------------------------------------------------
test.1.in:          1 |     0.000021  |     0.000029  |    0.000028  |    0.000025  |    0.000027
test.2.in:         10 |     0.000012  |     0.000013  |    0.000014  |    0.000016  |    0.000013
test.3.in:        100 |     0.000012  |     0.000012  |    0.000012  |    0.000017  |    0.000012
test.4.in:      1.000 |     0.000021  |     0.000015  |    0.000018  |    0.000022  |    0.000013
test.5.in:     10.000 |     0.000026  |     0.000021  |    0.000021  |    0.000042  |    0.000020
test.6.in:    100.000 |    NOT CHECK  |     0.000028  |    0.000030  |    0.000022  |    0.000027
test.7.in:  1.000.000 |    NOT CHECK  |    NOT CHECK  |    0.000035  |    0.000025  |    0.000029
test.8.in: 10.000.000 |    NOT CHECK  |    NOT CHECK  |    0.000045  |    0.000032  |    0.000031

Вывод:
Любая из реализаций показывает одинаково быстрое решение.
Это говорит нам о том что получение элемента по индексу - константно.
Собственно такое поведение и ожидалось, ведь внутри массив.


=================================================================================================
====(   Операция: удаление/извлечение элемента по индексу (из середины) массива (REMOVE)    )====
=================================================================================================
TEST: COLL_SIZE       |     SINGLE    |     VECTOR    |     FACTOR   |    MATRIX    |    STANDART 
------------------------------------------------------------------------------------------------
test.1.in:          1 |     0.000008  |     0.000008  |    0.000011  |    0.000015  |    0.000009
test.2.in:         10 |     0.000008  |     0.000009  |    0.000009  |    0.000037  |    0.000006
test.3.in:        100 |     0.000029  |     0.000028  |    0.000028  |    0.000301  |    0.000005
test.4.in:      1.000 |     0.000263  |     0.000262  |    0.000259  |    0.003200  |    0.000006
test.5.in:     10.000 |     0.003423  |     0.002546  |    0.002581  |    0.026926  |    0.000007
test.6.in:    100.000 |    NOT CHECK  |     0.026490  |    0.026454  |    0.356558  |    0.000026
test.7.in:  1.000.000 |    NOT CHECK  |    NOT CHECK  |    0.265019  |    3.047934  |    0.000237
test.8.in: 10.000.000 |    NOT CHECK  |    NOT CHECK  |    2.639774  |   29.629236  |    0.002420

Вывод:
Результат незначительно отличается, что вполне ожидаемо. 
Ведь при любой реализации время тратится на одинаковые действия - сдвиг оставшихся эелементов к началу массива.
Матричный массив чуть более долгий, потому что перекладывание элементов между массивами проходит более "тяжело".
Нативная реализация даже тут показала свою скорость но начиная со 100000 скорость роста его времени выполнения становится похожим на наши реализации.


=================================================================================================
======(       Операция: Добавления элемента по индексу (в середину) массива(INSERT)      )=======
=================================================================================================
TEST: COLL_SIZE       |     SINGLE    |     VECTOR    |     FACTOR   |    MATRIX    |    STANDART 
------------------------------------------------------------------------------------------------
test.1.in:          1 |     0.000023  |     0.000024  |    0.000019  |    0.000040  |    0.000016
test.2.in:         10 |     0.000137  |     0.000068  |    0.000085  |    0.000241  |    0.000031
test.3.in:        100 |     0.003942  |     0.001763  |    0.001575  |    0.015638  |    0.000156
test.4.in:      1.000 |     0.363720  |     0.164094  |    0.143082  |    1.494133  |    0.001772
test.5.in:     10.000 |    39.685706  |    16.382311  |   14.957861  |  154.668769  |    0.040459
test.6.in:    100.000 |     TOO SLOW  |     TOO SLOW  | 1604.640499  |    TOO SLOW  |    2.688631
test.7.in:  1.000.000 |     TOO SLOW  |     TOO SLOW  |    TOO SLOW  |    TOO SLOW  |  268.745378
test.8.in: 10.000.000 |     TOO SLOW  |     TOO SLOW  |    TOO SLOW  |    TOO SLOW  |    TOO SLOW

Вывод:
Тут ситуация похожа на удаление элементов и все наши реализации показываю примерно одинаковые результаты.
И, как и в прошлом варианте, матричный массив немного отстает, потому что перекладывание элементов в подмассивах проходит немного "тяжелее".
Нативная реализация ожидаемо быстрее, но разрыв не так уже велик, наша FACTOR реализация отстает всего лишь на порядок.


ИТОГО:
После всех проведенных тестов, совершенно очевидным становится - лидер наших гонок это FACTOR.
Она уступает лишь нативной реализации и отлично показала себя во всех тестах.
Также заметны проблемы данных структур данных, а конкретнее это операции удаления элемента и вставки по индексу.
Большое количество таких операций значительно сниит производительность и следует выбрать для приложения другую структуру данных, например связный список.

